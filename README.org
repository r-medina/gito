#+TITLE: gito
#+PROPERTY: header-args :eval no

Tool for managing source code more like =go get= (ie with opinions on
where code should live) - find code and stay organized easier!

* Download code

  #+begin_src text :noeval
    gito get github.com/r-medina/gito # defults to GOPATH[0]/src/github.com/... or $HOME/src/...
  #+end_src

  the =get= command needs a full(ish) name/url - from then on you can
  refer to repos by a subset of their names (eg "r-medina/gito" or
  "gito").


* Find out where repo is

  #+begin_src shell
    gito where r-medina/gito # $HOME/go/src/github.com/r-medina/gito
  #+end_src


  Can also find code with just repo name
  #+begin_src shell
    gito where gito # $HOME/go/src/github.com/r-medina/gito
  #+end_src

  Which you can easily cd into
  #+begin_src shell
    cd $(gito where gito)
  #+end_src


* Find repo online

  #+begin_src shell
    gito url gito         # https://github.com/r-medina/gito
    open $(gito url gito) # opens in brownser
  #+end_src


* TODO Tell gito where a repo lives

  not yet implemented

  #+begin_src shell
    gito set r-medina/gito <path> # saves the location information to path
    gito get r-medina/gito        # <path>
  #+end_src

  when a repo's location is set, only that name can be used, but you
  can set =r-medina/gito= and =gito= to =<path>= so that both work!

* TODO make alias for repo

  not yet implemented

  #+begin_src shell
    gito alias g github.com/mvdan/garble
    gito where g # $HOME/go/src/github.com/mvdan/garble
  #+end_src

  #+begin_src shell
    gito alias d dotfiles
    gito set dotfiles ~/.dotfiles # $HOME
    cd $(gito where d)
  #+end_src


* Usage

  #+begin_src text
    usage: gito [<flags>] <command> [<args> ...]

    Manage code intelligently.

    See http://github.com/r-medina/gito for documentation.

    Flags:
      --workspace=WORKSPACE which workspace to use (defaults to first in config)
        -w

    Commands:
      help
	show this message

      get <repo>
	download a repo

      where <repo>
	find out where repo lives

      url <repo>
	get the url of the repo (for web browsing)
  #+end_src


* Example Config

  gito cannot do shell expansion for now, so add full paths to the
  config file.

  #+begin_src yaml
    workspaces:
        - name: personal
          path: "/Users/ricky"
          aliases:
              g: gito
              d: dotfiles
          custom:
              dotfiles: "/Users/ricky/.dotfiles"
        - name: work
          path: "/Users/ricky/gh"
          overrideSrc: yes
          aliases:
              ghe: super-secret
          custom:
              super-secret: "somewhereElse/theMoneyMaker
  #+end_src


* Caveats

  - only works with git


* Notes while developing

  might actually be useful to run its own database for aliases and
  custom locations (gob file @ ~/.config/gito - also gito.json can
  live there)

  default location is in GOPATH, optional argument for path

  thinking of using urfave/cli
  - actually, not using a cli framework has been fine

  =mkdir -p=: https://gobyexample.com/directories

  [[https://golang.org/pkg/path/filepath/#SplitList][filepath.SplitList]] for splitting PATH style variables

  Config:

  #+begin_src yaml
    workspaces:
      - name: personal
        path: "~"
        aliases:
          g: gito
          d: dotfiles
        custom:
          dotfiles: "~/.dotfiles"
      - name: work
        path: "~/gh"
        overrideSrc: yes
        aliases:
          ghe: super-secret
        custom:
          super-secret: "~/somewhereElse/theMoneyMaker
  #+end_src

  - I don't want their to be an environment variable.
  - When user uses gito for first time, they get a default workspace
    with GOPATH


* TODOs

** TODO allow for configuration and different profiles

** TODO make sure url command works with things other than github

** TODO commands check for =.git= before returning results

** DONE make sure url command works for ssh and http clones
